# this workflow processes the hx rate fitting
# rule 1: generates

import pandas as pd

# set the config file path
configfile: '../config/config.yml'

# set benchmark dirpath
benchmark_dpath = config['output_dirpath'] + '/benchmark'

# set the python scripts path
scripts_dirpath = config['path_to_repo'] + '/scripts/hx_rate'
hx_rate_fit_python_path = scripts_dirpath + '/hxratefit_snakemake.py'
gen_time_specific_bkexch_path = scripts_dirpath + '/gen_time_specific_bkexch_corr.py'

sample_csv_fpath = config['output_dirpath'] + '/sample.csv'

name_wildcard_string = config['level_to_fpaths']*'/{name}'
hx_dist_fpath_expand_string = config['hx_ms_dist_fpaths_top_dir'] + name_wildcard_string + config['hx_ms_fpath_delim_string']

df = pd.read_csv(sample_csv_fpath)
prot_name = [x for x in df['name'].values]
sequence = [x for x in df['sequence'].values]
name_seq_dict = dict()
for ind, (pname, pseq) in enumerate(zip(prot_name, sequence)):
    name_seq_dict[pname] = pseq


rule all:
    input:  expand(config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle', name=prot_name)


if config['backexchange_correction']:

    if config['backexchange_correction_fpath'] is None:

        rule gen_tp_specific_bkexch:
            input:
                sample_csv_fpath = sample_csv_fpath
            params:
                rate_tol = config['rate_tol'],
                frac_threshold = config['frac_threshold'],
                frac_threshold_bound = config['frac_threshold_bound'],
                start_bound = config['start_bound'],
                end_bound = config['end_bound'],
                max_rate = config['max_rate'],
                min_num_paths = config['min_num_paths'],
                change_frac_threshold = config['change_frac_threshold']
            output:
                corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv',
                corr_plot_path = config['output_dirpath'] + '/bkexch_corr.pdf'
            benchmark:
                benchmark_dpath + '/gen_tp_specific_bkexch.benchmark.txt'
            shell:
                'python ' + gen_time_specific_bkexch_path + ' -s {input.sample_csv_fpath} -r {params.rate_tol} -f {params.frac_threshold} -b {params.frac_threshold_bound} -i {params.start_bound} -e {params.end_bound} -m {params.max_rate} -n {params.min_num_paths} -c {params.change_frac_threshold} -p {output.corr_plot_path} -o {output.corr_fpath}'

    else:

        rule copy_bkexch_corr_fpath:
            input:
                input_corr_fpath = config['backexchange_correction_fpath']
            output:
                config['output_dirpath'] + '/bkexch_corr.csv'
            benchmark:
                benchmark_dpath + '/copy_bkexch_corr_fpath.benchmark.txt'
            shell:
                "cp {input.input_corr_fpath} {output}"

    if config['usr_backexchange'] is None:

        rule fit_hx_rate:
            input:
                hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
                bkexch_corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv'
            params:
                prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
                prot_name = '{name}',
                d2o_frac = config['d2o_fraction'],
                d2o_purity = config['d2o_purity'],
                opt_iter = config['opt_iter'],
                opt_temp = config['opt_temp'],
                opt_step_size = config['opt_step_size'],
                multi_proc = config['multi_proc'],
                num_cores = config['number_of_cores']
            resources:
                threads = config['number_of_cores']
            output:
                pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
                rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
                iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
                plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
            benchmark:
                benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt',
            shell:
                'python ' + hx_rate_fit_python_path + ' -i {input.hx_dist_fpath} -s {params.prot_seq} -n {params.prot_name} -df {params.d2o_frac} -dp {params.d2o_purity} -ot {params.opt_temp} -os {params.opt_step_size} -oi {params.opt_iter} -bf {input.bkexch_corr_fpath} -mp {params.multi_proc} -nc {params.num_cores} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'

    else:

        rule fit_hx_rate:
            input:
                hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
                bkexch_corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv'
            params:
                prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
                prot_name = '{name}',
                d2o_frac = config['d2o_fraction'],
                d2o_purity = config['d2o_purity'],
                user_backexchange = config['usr_backexchange'],
                opt_iter = config['opt_iter'],
                opt_temp = config['opt_temp'],
                opt_step_size = config['opt_step_size'],
                multi_proc = config['multi_proc'],
                num_cores = config['number_of_cores']
            resources:
                threads = config['number_of_cores']
            output:
                pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
                rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
                iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
                plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
            benchmark:
                benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt',
            shell:
                'python ' + hx_rate_fit_python_path + ' -i {input.hx_dist_fpath} -s {params.prot_seq} -n {params.prot_name} -df {params.d2o_frac} -dp {params.d2o_purity} -ot {params.opt_temp} -os {params.opt_step_size} -oi {params.opt_iter} -ub {params.user_backexchange} -bf {input.bkexch_corr_fpath} -mp {params.multi_proc} -nc {params.num_cores} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'




else:

    if config['usr_backexchange'] is None:

        rule fit_hx_rate:
            input:
                hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
                bkexch_corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv'
            params:
                prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
                prot_name = '{name}',
                d2o_frac = config['d2o_fraction'],
                d2o_purity = config['d2o_purity'],
                opt_iter = config['opt_iter'],
                opt_temp = config['opt_temp'],
                opt_step_size = config['opt_step_size'],
                multi_proc = config['multi_proc'],
                num_cores = config['number_of_cores']
            resources:
                threads = config['number_of_cores']
            output:
                pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
                rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
                iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
                plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
            benchmark:
                benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt',
            shell:
                'python ' + hx_rate_fit_python_path + ' -i {input.hx_dist_fpath} -s {params.prot_seq} -n {params.prot_name} -df {params.d2o_frac} -dp {params.d2o_purity} -ot {params.opt_temp} -os {params.opt_step_size} -oi {params.opt_iter} -bf {input.bkexch_corr_fpath} -mp {params.multi_proc} -nc {params.num_cores} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'

    else:

        rule fit_hx_rate:
            input:
                hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
                bkexch_corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv'
            params:
                prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
                prot_name = '{name}',
                d2o_frac = config['d2o_fraction'],
                d2o_purity = config['d2o_purity'],
                user_backexchange = config['usr_backexchange'],
                opt_iter = config['opt_iter'],
                opt_temp = config['opt_temp'],
                opt_step_size = config['opt_step_size'],
                multi_proc = config['multi_proc'],
                num_cores = config['number_of_cores']
            resources:
                threads = config['number_of_cores']
            output:
                pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
                rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
                iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
                plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
            benchmark:
                benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt',
            shell:
                'python ' + hx_rate_fit_python_path + ' -i {input.hx_dist_fpath} -s {params.prot_seq} -n {params.prot_name} -df {params.d2o_frac} -dp {params.d2o_purity} -ot {params.opt_temp} -os {params.opt_step_size} -oi {params.opt_iter} -ub {params.user_backexchange} -bf {input.bkexch_corr_fpath} -mp {params.multi_proc} -nc {params.num_cores} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'

