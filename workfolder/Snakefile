# this workflow processes the hx rate fitting
# rule 1: generates

import os
import glob
import pandas as pd

# set the config file path
configfile: '../config/config.yml'

# set benchmark dirpath
benchmark_dpath = config['output_dirpath'] + '/benchmark'
rate_output_path = config['output_dirpath'] + '/rates'
backexchange_output_path = config['output_dirpath'] + '/backexchange'

# set the python scripts path
scripts_dirpath = config['path_to_repo'] + '/scripts/hx_rate'
hx_rate_fit_python_path = scripts_dirpath + '/hx_rate_fit.py'
gen_time_specific_bkexch_path = scripts_dirpath + '/gen_time_specific_bkexch_corr.py'


def gen_prot_name_seq_list(hxms_dist_top_dir, hxms_end_string, levels_to_fpaths, libinfo_fpath):

    libinfo_df = pd.read_json(libinfo_fpath)
    hx_ms_dist_file_list = glob.glob(hxms_dist_top_dir+'/*'*levels_to_fpaths+hxms_end_string)

    name_list = []
    seq_list = []

    for ind, hx_ms_dist_fpath in enumerate(hx_ms_dist_file_list):

        hxms_df = pd.read_csv(hx_ms_dist_fpath)

        # check whether the data frame is empty or not
        if not hxms_df.empty:

            dpath, hx_ms_dist_fname = os.path.split(hx_ms_dist_fpath)

            prot_name = hx_ms_dist_fname.strip(hxms_end_string)

            if prot_name in libinfo_df['name'].values:

                name_list.append(prot_name)
                prot_seq = libinfo_df[libinfo_df['name'] == prot_name]['sequence'].values[0]
                seq_list.append(prot_seq)

    return name_list, seq_list

prot_name_list, prot_seq_list = gen_prot_name_seq_list(hxms_dist_top_dir=config['hx_ms_dist_fpaths_top_dir'], hxms_end_string=config['hx_ms_fpath_delim_string'], levels_to_fpaths=config['levels_to_fpaths'], libinfo_fpath=config['library_info_json_fpath'])


name_seq_dict = dict()
for ind, (pname, pseq) in enumerate(zip(prot_name_list, prot_seq_list)):
    name_seq_dict[pname] = pseq


hx_dist_fpaths_gen_ = config['hx_ms_dist_fpaths_top_dir'] + '/{name}'*config['levels_to_fpaths'] + config['hx_ms_fpath_delim_string']


rule all:
    input:  expand(rate_output_path + '/{name}/{name}_hx_rate_fit.pickle', name=prot_name_list)


if config['backexchange_correction']:

    if config['backexchange_correction_fpath'] is None:

        rule gen_tp_specific_bkexch:
            input:
                list_of_hx_fpaths = list(expand(hx_dist_fpaths_gen_, name=prot_name_list))
            params:
                delim_string = config['hx_ms_fpath_delim_string'],
                rate_tol = config['rate_tol'],
                frac_threshold = config['frac_threshold'],
                frac_threshold_bound = config['frac_threshold_bound'],
                start_bound = config['start_bound'],
                end_bound = config['end_bound'],
                max_rate = config['max_rate'],
                min_num_paths = config['min_num_paths'],
                change_frac_threshold = config['change_frac_threshold']
            output:
                corr_fpath = backexchange_output_path + '/bkexch_corr.csv',
                corr_plot_path = backexchange_output_path + '/bkexch_corr.pdf'
            benchmark:
                benchmark_dpath + '/gen_tp_specific_bkexch.benchmark.txt'
            shell:
                'python ' + gen_time_specific_bkexch_path + ' -l {input.list_of_hx_fpaths} -s {params.delim_string} -r {params.rate_tol} -f {params.frac_threshold} -b {params.frac_threshold_bound} -i {params.start_bound} -e {params.end_bound} -m {params.max_rate} -n {params.min_num_paths} -c {params.change_frac_threshold} -p {output.corr_plot_path} -o {output.corr_fpath}'

    else:

        rule copy_bkexch_corr_fpath:
            input:
                input_corr_fpath = config['backexchange_correction_fpath']
            output:
                backexchange_output_path + '/bkexch_corr.csv'
            benchmark:
                benchmark_dpath + '/copy_bkexch_corr_fpath.benchmark.txt'
            shell:
                "cp {input.input_corr_fpath} {output}"


    rule fit_hx_rate:
        input:
            hx_dist_fpath = hx_dist_fpaths_gen_,
            bkexch_corr_fpath = backexchange_output_path + '/bkexch_corr.csv'
        params:
            prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
            prot_name = '{name}',
            d2o_frac = config['d2o_fraction'],
            d2o_purity = config['d2o_purity'],
            num_chains = config['num_chains'],
            num_warmups = config['num_warmups'],
            num_samples = config['num_samples'],
            adjust_backexchange = config['adjust_backexchange']
        output:
            pk_file = rate_output_path + '/{name}/{name}_hx_rate_fit.pickle',
            rate_csv_file = rate_output_path + '/{name}/{name}_hx_rate.csv',
            iso_dist_file = rate_output_path + '/{name}/{name}_hx_rate_theo_dist.csv',
            plot_file = rate_output_path + '/{name}/{name}_hx_rate.pdf'
        benchmark:
            benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt'
        shell:
            'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_purity} -bcf {input.bkexch_corr_fpath} -adb {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'

else:

    rule fit_hx_rate:
        input:
            hx_dist_fpath = hx_dist_fpaths_gen_
        params:
            prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
            prot_name = '{name}',
            d2o_frac = config['d2o_fraction'],
            d2o_purity = config['d2o_purity'],
            num_chains = config['num_chains'],
            num_warmups = config['num_warmups'],
            num_samples = config['num_samples'],
            adjust_backexchange = config['adjust_backexchange']
        output:
            pk_file = rate_output_path + '/{name}/{name}_hx_rate_fit.pickle',
            rate_csv_file = rate_output_path + '/{name}/{name}_hx_rate.csv',
            iso_dist_file = rate_output_path + '/{name}/{name}_hx_rate_theo_dist.csv',
            plot_file = rate_output_path + '/{name}/{name}_hx_rate.pdf'
        benchmark:
            benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt'
        shell:
            'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_purity} -adb {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'
#
#
# # this workflow processes the hx rate fitting
# # rule 1: generates
#
# import pandas as pd
#
# # set the config file path
# configfile: '../config/config.yml'
#
# # set benchmark dirpath
# benchmark_dpath = config['output_dirpath'] + '/benchmark'
#
# # set the python scripts path
# scripts_dirpath = config['path_to_repo'] + '/scripts/hx_rate'
# hx_rate_fit_python_path = scripts_dirpath + '/hx_rate_fit.py'
# gen_time_specific_bkexch_path = scripts_dirpath + '/gen_time_specific_bkexch_corr.py'
#
# sample_csv_fpath = config['output_dirpath'] + '/sample/sample.csv'
#
# name_wildcard_string = config['level_to_fpaths']*'/{name}'
# hx_dist_fpath_expand_string = config['hx_ms_dist_fpaths_top_dir'] + name_wildcard_string + config['hx_ms_fpath_delim_string']
#
# df = pd.read_csv(sample_csv_fpath)
# prot_name = [x for x in df['name'].values]
# sequence = [x for x in df['sequence'].values]
# name_seq_dict = dict()
# for ind, (pname, pseq) in enumerate(zip(prot_name, sequence)):
#     name_seq_dict[pname] = pseq
#
#
# rule all:
#     input:  expand(config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle', name=prot_name)
#
#
# if config['backexchange_correction']:
#
#     if config['backexchange_correction_fpath'] is None:
#
#         rule gen_tp_specific_bkexch:
#             input:
#                 sample_csv_fpath = sample_csv_fpath
#             params:
#                 rate_tol = config['rate_tol'],
#                 frac_threshold = config['frac_threshold'],
#                 frac_threshold_bound = config['frac_threshold_bound'],
#                 start_bound = config['start_bound'],
#                 end_bound = config['end_bound'],
#                 max_rate = config['max_rate'],
#                 min_num_paths = config['min_num_paths'],
#                 change_frac_threshold = config['change_frac_threshold']
#             output:
#                 corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv',
#                 corr_plot_path = config['output_dirpath'] + '/bkexch_corr.pdf'
#             benchmark:
#                 benchmark_dpath + '/gen_tp_specific_bkexch.benchmark.txt'
#             shell:
#                 'python ' + gen_time_specific_bkexch_path + ' -s {input.sample_csv_fpath} -r {params.rate_tol} -f {params.frac_threshold} -b {params.frac_threshold_bound} -i {params.start_bound} -e {params.end_bound} -m {params.max_rate} -n {params.min_num_paths} -c {params.change_frac_threshold} -p {output.corr_plot_path} -o {output.corr_fpath}'
#
#     else:
#
#         rule copy_bkexch_corr_fpath:
#             input:
#                 input_corr_fpath = config['backexchange_correction_fpath']
#             output:
#                 config['output_dirpath'] + '/bkexch_corr.csv'
#             benchmark:
#                 benchmark_dpath + '/copy_bkexch_corr_fpath.benchmark.txt'
#             shell:
#                 "cp {input.input_corr_fpath} {output}"
#
#
#     rule fit_hx_rate:
#         input:
#             hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
#             bkexch_corr_fpath = config['output_dirpath'] + '/bkexch_corr.csv'
#         params:
#             prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
#             prot_name = '{name}',
#             d2o_frac = config['d2o_fraction'],
#             d2o_purity = config['d2o_purity'],
#             num_chains = config['num_chains'],
#             num_warmups = config['num_warmups'],
#             num_samples = config['num_samples'],
#             adjust_backexchange = config['adjust_backexchange']
#         output:
#             pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
#             rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
#             iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
#             plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
#         benchmark:
#             benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt'
#         shell:
#             'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_purity} -bcf {input.bkexch_corr_fpath} -adb {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'
#
# else:
#
#     rule fit_hx_rate:
#         input:
#             hx_dist_fpath = config['hx_ms_dist_fpaths_top_dir'] + config['level_to_fpaths']*'/{name}' + config['hx_ms_fpath_delim_string'],
#         params:
#             prot_seq = lambda wildcards: name_seq_dict[wildcards.name],
#             prot_name = '{name}',
#             d2o_frac = config['d2o_fraction'],
#             d2o_purity = config['d2o_purity'],
#             num_chains = config['num_chains'],
#             num_warmups = config['num_warmups'],
#             num_samples = config['num_samples'],
#             adjust_backexchange = config['adjust_backexchange']
#         output:
#             pk_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_fit.pickle',
#             rate_csv_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.csv',
#             iso_dist_file = config['output_dirpath'] + '/{name}/{name}_hx_rate_theo_dist.csv',
#             plot_file = config['output_dirpath'] + '/{name}/{name}_hx_rate.pdf'
#         benchmark:
#             benchmark_dpath + '/{name}_fit_hx_rate.benchmark.txt'
#         shell:
#             'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_purity} -adb {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'
