# this workflow processes the hx rate fitting
# rule 1: generates

import os
import glob
import pandas as pd
import numpy as np

# set the config file path
configfile: 'config_merge.yml'

# set benchmark dirpath
config_dirpath = config['path_to_repo'] + '/config'
benchmark_dpath = config['output_dirpath'] + '/benchmark'
backexchange_output_path = config['output_dirpath'] + '/backexchange'
merge_dpath = config['output_dirpath'] + '/merge_distribution'
hxrate_dpath = config['output_dirpath'] + '/rates'
dg_output_path = config['output_dirpath'] + '/dG'
summary_output_path = config['output_dirpath'] + '/summary'

# set the python scripts path
scripts_dirpath = config['path_to_repo'] + '/scripts/hx_rate'
hx_rate_fit_python_path = scripts_dirpath + '/hx_rate_fit.py'
merge_data_high_low_python = scripts_dirpath + '/merge_high_low_ph_data.py'
gen_backexch_array_python = scripts_dirpath + '/generate_backexchange_for_proteins.py'
gen_time_specific_bkexch_path = scripts_dirpath + '/gen_time_specific_bkexch_corr.py'
gen_backexch_corr_low_high_python_path = scripts_dirpath + '/gen_backexchange_corr_low_high_ph.py'
dg_opt_python_path = scripts_dirpath + '/dG_opt.py'
summary_python_path = scripts_dirpath + '/gen_summary.py'


def check_hxdist_fpath(hxms_dir, level_to_fpaths, prot_rt_name, file_end_string):

    file_valid = False

    hx_fpath = hxms_dir + ('/' + prot_rt_name) * level_to_fpaths + file_end_string

    # check if fpath exists
    if os.path.exists(hx_fpath):
        # check if the file size is greater than 0
        if os.stat(hx_fpath).st_size > 0:
            hx_df = pd.read_csv(hx_fpath)
            # check if the file is empty
            if not hx_df.empty:
                file_valid = True

    return hx_fpath, file_valid


def gen_prot_name_from_rt_name(rt_name):
    prot_name_chars = rt_name.split('_')
    del prot_name_chars[-1]
    prot_name = '_'.join(x for x in prot_name_chars)
    if prot_name.endswith('.pdb'):
        prot_name = prot_name.strip('.pdb')
    return prot_name


def find_no_match(prot_name_rt_arr, prot_name_rt_arr_match):

    no_match = []

    for name in prot_name_rt_arr:
        if name not in prot_name_rt_arr_match:
            no_match.append(name)

    return no_match


def gen_match_protein_rt_list(low_ph_libinfo_fpath,
                              high_ph_libinfo_fpath,
                              lowph_protein_rt_column_name,
                              highph_protein_rt_column_name,
                              low_ph_hxms_dir,
                              low_ph_level_to_fpaths,
                              low_ph_hxms_end_string,
                              high_ph_hxms_dir,
                              high_ph_level_to_fpaths,
                              high_ph_hxms_end_string,
                              rt_window=2):

    low_ph_libinfo_df = pd.read_json(low_ph_libinfo_fpath)
    high_ph_libinfo_df = pd.read_json(high_ph_libinfo_fpath)

    # generate matching protein names from the library info first
    low_ph_name_rt_arr = np.unique(low_ph_libinfo_df[lowph_protein_rt_column_name].values)
    high_ph_name_rt_arr = np.unique(high_ph_libinfo_df[highph_protein_rt_column_name].values)

    low_ph_name_list = ['_'.join(x.split('_')[:-1]) for x in low_ph_name_rt_arr]
    high_ph_name_list = ['_'.join(x.split('_')[:-1]) for x in high_ph_name_rt_arr]

    low_ph_match_rtname_list = []
    high_ph_match_rtname_list = []

    for ind, low_ph_name_ in enumerate(low_ph_name_list):

        low_ph_rt_name = low_ph_name_rt_arr[ind]
        low_ph_rt = float(low_ph_rt_name.split('_')[-1])
        high_ph_rt_name_matches = [high_ph_name_rt_arr[ind2] for ind2, x in enumerate(high_ph_name_list) if x == low_ph_name_]

        if len(high_ph_rt_name_matches) > 0:

            for high_ph_rt_name in high_ph_rt_name_matches:

                high_ph_rt = float(high_ph_rt_name.split('_')[-1])

                if abs(high_ph_rt - low_ph_rt) <= rt_window:

                    lowph_fpath, lowph_file_valid = check_hxdist_fpath(hxms_dir=low_ph_hxms_dir,
                        level_to_fpaths=low_ph_level_to_fpaths,
                        prot_rt_name=low_ph_rt_name,
                        file_end_string=low_ph_hxms_end_string)

                    highph_fpath, highph_file_valid = check_hxdist_fpath(hxms_dir=high_ph_hxms_dir,
                        level_to_fpaths=high_ph_level_to_fpaths,
                        prot_rt_name=high_ph_rt_name,
                        file_end_string=high_ph_hxms_end_string)

                    if lowph_file_valid:
                        if highph_file_valid:
                            low_ph_match_rtname_list.append(low_ph_rt_name)
                            high_ph_match_rtname_list.append(high_ph_rt_name)

    return low_ph_match_rtname_list, high_ph_match_rtname_list


def gen_nomatch_protein_list(low_ph_libinfo_fpath,
                             high_ph_libinfo_fpath,
                             lowph_protein_rt_column_name,
                             highph_protein_rt_column_name,
                             low_ph_hxms_dir,
                             low_ph_level_to_fpaths,
                             low_ph_hxms_end_string,
                             high_ph_hxms_dir,
                             high_ph_level_to_fpaths,
                             high_ph_hxms_end_string,
                             low_ph_value,
                             high_ph_value,
                             rt_window=2):

    low_ph_libinfo_df = pd.read_json(low_ph_libinfo_fpath)
    high_ph_libinfo_df = pd.read_json(high_ph_libinfo_fpath)

    # generate matching protein names from the library info first
    low_ph_name_rt_arr = np.unique(low_ph_libinfo_df[lowph_protein_rt_column_name].values)
    high_ph_name_rt_arr = np.unique(high_ph_libinfo_df[highph_protein_rt_column_name].values)

    match_lowph_rtname, match_highph_rtname = gen_match_protein_rt_list(low_ph_libinfo_fpath=low_ph_libinfo_fpath,
        high_ph_libinfo_fpath=high_ph_libinfo_fpath,
        lowph_protein_rt_column_name=lowph_protein_rt_column_name,
        highph_protein_rt_column_name=highph_protein_rt_column_name,
        low_ph_hxms_dir=low_ph_hxms_dir,
        low_ph_level_to_fpaths=low_ph_level_to_fpaths,
        low_ph_hxms_end_string=low_ph_hxms_end_string,
        high_ph_hxms_dir=high_ph_hxms_dir,
        high_ph_level_to_fpaths=high_ph_level_to_fpaths,
        high_ph_hxms_end_string=high_ph_hxms_end_string,
        rt_window=rt_window)

    low_ph_rtname_nomatch_list = find_no_match(prot_name_rt_arr=low_ph_name_rt_arr,
        prot_name_rt_arr_match=match_lowph_rtname)
    high_ph_rtname_nomatch_list = find_no_match(prot_name_rt_arr=high_ph_name_rt_arr,
        prot_name_rt_arr_match=match_highph_rtname)

    if len(low_ph_rtname_nomatch_list) == 0:
        low_ph_rtname_nomatch_list = [match_lowph_rtname[0]]
    if len(high_ph_rtname_nomatch_list) == 0:
        high_ph_rtname_nomatch_list = [match_highph_rtname[0]]

    prot_rt_name_list = []

    hxfpath_dict = dict()
    prot_name_dict = dict()
    prot_seq_dict = dict()
    ph_dict = dict()

    for lowphrtname_nomatch in low_ph_rtname_nomatch_list:
        lowphrt_fpath, lowphrt_file_valid = check_hxdist_fpath(prot_rt_name=lowphrtname_nomatch,
            hxms_dir=low_ph_hxms_dir,
            level_to_fpaths=low_ph_level_to_fpaths,
            file_end_string=low_ph_hxms_end_string)
        if lowphrt_file_valid:
            prot_rt_name_list.append(lowphrtname_nomatch)
            hxfpath_dict[lowphrtname_nomatch] = lowphrt_fpath
            lowph_prot_seq = low_ph_libinfo_df[low_ph_libinfo_df[lowph_protein_rt_column_name] == lowphrtname_nomatch]['sequence'].values[0]
            prot_seq_dict[lowphrtname_nomatch] = lowph_prot_seq
            prot_name_dict[lowphrtname_nomatch] = gen_prot_name_from_rt_name(lowphrtname_nomatch)
            ph_dict[lowphrtname_nomatch] = low_ph_value


    for highphrtname_nomatch in high_ph_rtname_nomatch_list:
        highphrt_fpath, highphrt_file_valid = check_hxdist_fpath(prot_rt_name=highphrtname_nomatch,
            hxms_dir=high_ph_hxms_dir,
            level_to_fpaths=high_ph_level_to_fpaths,
            file_end_string=high_ph_hxms_end_string)
        if highphrt_file_valid:
            highph_prot_seq = high_ph_libinfo_df[high_ph_libinfo_df[highph_protein_rt_column_name] == highphrtname_nomatch]['sequence'].values[0]
            prot_rt_name_list.append(highphrtname_nomatch)
            hxfpath_dict[highphrtname_nomatch] = highphrt_fpath
            prot_seq_dict[highphrtname_nomatch] = highph_prot_seq
            prot_name_dict[highphrtname_nomatch] = gen_prot_name_from_rt_name(highphrtname_nomatch)
            ph_dict[highphrtname_nomatch] = high_ph_value

    return prot_rt_name_list, hxfpath_dict, prot_seq_dict, prot_name_dict, ph_dict


prot_rt_name_list_, hxfpath_dict_, prot_seq_dict_, prot_name_dict_, ph_dict_ = gen_nomatch_protein_list(low_ph_libinfo_fpath=config['low_ph_library_info'], lowph_protein_rt_column_name=config['lowph_protein_rt_column_name'], high_ph_libinfo_fpath=config['high_ph_library_info'], highph_protein_rt_column_name=config['highph_protein_rt_column_name'], low_ph_hxms_dir=config['low_ph_hxms_fpath_dir'], low_ph_level_to_fpaths=config['level_to_fpaths_low_ph'], low_ph_hxms_end_string=config['low_ph_hxms_fpath_delim_str'], high_ph_hxms_dir=config['high_ph_hxms_fpath_dir'], high_ph_level_to_fpaths=config['level_to_fpaths_high_ph'], high_ph_hxms_end_string=config['high_ph_hxms_fpath_delim_str'], rt_window=config['merge_rt_window'], low_ph_value=config['low_pH'], high_ph_value=config['high_pH'])


# set_up_backexchange_correction_fpath
low_backexchange_corr_fpath = backexchange_output_path + '/low_ph_bkexch_corr.csv'
high_backexchange_corr_fpath = backexchange_output_path + '/high_ph_bkexch_corr.csv'
bkexch_corr_fpath_dict = dict()
bkexch_corr_fpath_dict[config['low_pH']] = low_backexchange_corr_fpath
bkexch_corr_fpath_dict[config['high_pH']] = high_backexchange_corr_fpath

# setup d2o frac dict
d2o_frac_dict = dict()
d2o_frac_dict[config['low_pH']]= config['low_ph_d2o_frac']
d2o_frac_dict[config['high_pH']] = config['high_ph_d2o_frac']

# setup d2o pur dict
d2o_pur_dict = dict()
d2o_pur_dict[config['low_pH']]= config['low_ph_d2o_pur']
d2o_pur_dict[config['high_pH']] = config['high_ph_d2o_pur']

# generate python shell commands here for hx rate fitting
# set a default shell line with both adjust backexchange and sample backexchange options set to true
sample_backexchange_param = '--sample_backexchange'
adjust_backexchange_param = '--adjust_backexchange'

if config['adjust_backexchange']:
    if config['sample_backexchange']:
        sample_backexchange_param = sample_backexchange_param
        adjust_backexchange_param = adjust_backexchange_param
    else:
        sample_backexchange_param = '--no-sample_backexchange'
        adjust_backexchange_param = adjust_backexchange_param
else:
    if config['sample_backexchange']:
        sample_backexchange_param = sample_backexchange_param
        adjust_backexchange_param = '--no-adjust_backexchange'
    else:
        sample_backexchange_param = '--no-sample_backexchange'
        adjust_backexchange_param = '--no-adjust_backexchange'


netcharge_param = ''
if config['net_charge_corr']:
    netcharge_param = '--netcharge'
else:
    netcharge_param = '--no-netcharge'


if config['dg_calc']:
    rule all:
        input:  expand(dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_data.pickle', prot_rt_name=prot_rt_name_list_),
                summary_output_path + '/summary_rate_nomatches.csv',
                summary_output_path + '/summary_dg_nomatches.csv'
else:
    rule all:
        input:  expand(hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate_fit.pickle', prot_rt_name=prot_rt_name_list_),
                summary_output_path + '/summary_rate_nomatches.csv',


rule fit_hx_rates_:
    input:
        hx_dist_fpath = lambda wildcards: hxfpath_dict_[wildcards.prot_rt_name],
        bkexch_corr_fpath = lambda wildcards: bkexch_corr_fpath_dict[ph_dict_[wildcards.prot_rt_name]]
    params:
        prot_seq = lambda wildcards: prot_seq_dict_[wildcards.prot_rt_name],
        prot_name = lambda wildcards: prot_name_dict_[wildcards.prot_rt_name],
        d2o_frac = lambda wildcards: d2o_frac_dict[ph_dict_[wildcards.prot_rt_name]],
        d2o_pur = lambda wildcards: d2o_pur_dict[ph_dict_[wildcards.prot_rt_name]],
        adjust_backexchange = adjust_backexchange_param,
        sample_backexchange = sample_backexchange_param,
        num_chains = config['num_chains'],
        num_warmups = config['num_warmups'],
        num_samples = config['num_samples']
    output:
        pk_file = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate_fit.pickle',
        rate_csv_file = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate.csv',
        iso_dist_file = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate_theo_dist.csv',
        plot_file = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate.pdf',
        posterior_plot_file = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_posteriors.pdf'
    benchmark:
        benchmark_dpath + '/{prot_rt_name}_fit_hx_rate.benchmark.txt'
    # threads: config['num_chains']
    shell:
        'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_pur} -bcf {input.bkexch_corr_fpath} {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} {params.sample_backexchange} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -opp {output.posterior_plot_file} -od {output.iso_dist_file}'


rule summary_rate:
    input:
        list_of_files = expand(hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate_fit.pickle', prot_rt_name=prot_rt_name_list_)
    params:
        mode = 'rate'
    output:
        output_path = summary_output_path + '/summary_rate_nomatches.csv'
    benchmark:
        benchmark_dpath + '/summary_rate_nomatches.benchmark.txt'
    shell:
        'python ' + summary_python_path + ' -l {input.list_of_files} -m {params.mode} -o {output.output_path}'


if config['dg_calc']:

    rule dg_calc_merge_dist:
        input:
            hx_rate_csv_fpath = hxrate_dpath + '/{prot_rt_name}/{prot_rt_name}_hx_rate.csv',
            dg_intpol_fpath = config_dirpath + '/newrect.pickle',
            pdb_fpath = lambda wildcards: config['pdb_fpaths_dir'] + '/'+prot_name_dict_[wildcards.prot_rt_name] + '.pdb',
        params:
            pH = lambda wildcards: ph_dict_[wildcards.prot_rt_name],
            temp = config['temp'],
            nterm = config['nterm'],
            cterm = config['cterm'],
            net_charge_corr = netcharge_param,
            anneal_time = config['anneal_time'],
            anneal_update_interval = config['anneal_update_interval']
        output:
            traj_fpath = dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_traj.csv',
            anneal_data_csv = dg_output_path + '/{prot_rt_name}/{prot_rt_name}_anneal_data.csv',
            dg_csv_output = dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_data.csv',
            dg_data_output = dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_data.pickle',
            dg_plot_path = dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_data.pdf',
        benchmark:
            benchmark_dpath + '/{prot_rt_name}_dg_calc.benchmark.txt'
        shell:
            'python ' + dg_opt_python_path + ' -hx {input.hx_rate_csv_fpath} -pdb {input.pdb_fpath} -dip {input.dg_intpol_fpath} -p {params.pH} -t {params.temp} -nt {params.nterm} -ct {params.cterm} {params.net_charge_corr} -au {params.anneal_update_interval} -at {params.anneal_time} -tf {output.traj_fpath} -af {output.anneal_data_csv} -df {output.dg_csv_output} -dpf {output.dg_data_output} -po {output.dg_plot_path}'


    rule summary_dg:
        input:
            list_of_files = expand(dg_output_path + '/{prot_rt_name}/{prot_rt_name}_dg_data.pickle', prot_rt_name=prot_rt_name_list_)
        params:
            mode = 'dg'
        output:
            output_path = summary_output_path + '/summary_dg.csv'
        benchmark:
            benchmark_dpath + '/summary_dg_nomatches.benchmark.txt'
        shell:
            'python ' + summary_python_path + ' -l {input.list_of_files} -m {params.mode} -o {output.output_path}'


    #
    #
    # # this workflow processes the hx rate fitting
    # # rule 1: generates
    #
    # import pandas as pd
    #
    # # set the config file path
    # configfile: '../config/config_merge.yml'
    #
    # # set benchmark dirpath
    # benchmark_dpath = config['output_dirpath'] + '/benchmark'
    # sample_dpath = config['output_dirpath'] + '/sample'
    # backexchange_dpath = config['output_dirpath'] + '/backexchange'
    # merge_dpath = config['output_dirpath'] + '/merge_distribution'
    # hxrate_dpath = config['output_dirpath'] + '/hxrate_output'
    #
    # # set the python scripts path
    # scripts_dirpath = config['path_to_repo'] + '/scripts/hx_rate'
    # hx_rate_fit_python_path = scripts_dirpath + '/hx_rate_fit.py'
    # merge_data_high_low_python = scripts_dirpath + '/merge_high_low_ph_data.py'
    # gen_backexch_array_python = scripts_dirpath + '/generate_backexchange_for_proteins.py'
    #
    # # hi low ph list filepath
    # merge_ph_list_fpath = backexchange_dpath + '/high_low_backexchange_list.csv'
    #
    # hi_low_bkex_df = pd.read_csv(merge_ph_list_fpath)
    # low_name_list_ = list(hi_low_bkex_df['low_ph_protein_name'].values)
    # high_name_list_ = list(hi_low_bkex_df['high_ph_protein_name'].values)
    #
    # out_name_list = []
    # low_name_dict = dict()
    # high_name_dict = dict()
    # high_ph_bkexc_dict = dict()
    # low_ph_bkexch_dict = dict()
    # seq_dict = dict()
    #
    # for num2 in range(len(low_name_list_)):
    #     low_high_name = low_name_list_[num2] + '_' + high_name_list_[num2]
    #     out_name_list.append(low_high_name)
    #     high_ph_bkexc_dict[low_high_name] = hi_low_bkex_df['high_ph_backexchange'].values[num2]
    #     low_ph_bkexch_dict[low_high_name] = hi_low_bkex_df['low_ph_backexchange_new'].values[num2]
    #     seq_dict[low_high_name] = hi_low_bkex_df['sequence'].values[num2]
    #     low_name_dict[low_high_name] = low_name_list_[num2]
    #     high_name_dict[low_high_name] = high_name_list_[num2]
    #
    # rule all:
    #     input:  expand(hxrate_dpath + '/{low_high_name}/{low_high_name}_hx_rate_fit.pickle', low_high_name=out_name_list)
    #
    #
    # rule merge_data_high_low:
    #     input:
    #         lowph_fpath = lambda wildcards: config['low_ph_hxms_fpath_dir'] + config['low_ph_level_to_fpaths']*'/'+low_name_dict[wildcards.low_high_name] + config['low_ph_hxms_fpath_delim_str'],
    #         highph_fpath = lambda wildcards: config['high_ph_hxms_fpath_dir'] + config['high_ph_level_to_fpaths']*'/'+high_name_dict[wildcards.low_high_name] + config['high_ph_hxms_fpath_delim_str'],
    #         lowph_corr_fpath = backexchange_dpath + '/low_ph_bkexch_corr.csv',
    #         highph_corr_fpath = backexchange_dpath + '/high_ph_bkexch_corr.csv'
    #     params:
    #         prot_seq = lambda wildcards: seq_dict[wildcards.low_high_name],
    #         lowph_d2o_frac = config['low_ph_d2o_frac'],
    #         lowph_d2o_pur = config['low_ph_d2o_pur'],
    #         highph_d2o_frac = config['high_ph_d2o_frac'],
    #         highph_d2o_pur = config['high_ph_d2o_pur'],
    #         low_ph_bkexch = lambda wildcards: low_ph_bkexch_dict[wildcards.low_high_name],
    #         high_ph_bkexch = lambda wildcards: high_ph_bkexc_dict[wildcards.low_high_name]
    #     output:
    #         mergebkex_output = merge_dpath + '/{low_high_name}/{low_high_name}_merge_backexchange.csv',
    #         mergebkex_corr_output = merge_dpath + '/{low_high_name}/{low_high_name}_merge_backexchange_correction.csv',
    #         merge_dist_output = merge_dpath + '/{low_high_name}/{low_high_name}_merge_hxms_dist.csv',
    #         merge_factor_output = merge_dpath + '/{low_high_name}/{low_high_name}_merge_factor.csv',
    #         merge_plot_output = merge_dpath + '/{low_high_name}/{low_high_name}_merge_hxms_dist_plot.pdf'
    #     benchmark:
    #         benchmark_dpath + '/{low_high_name}_merge_data_high_low.benchmark.txt'
    #     shell:
    #         'python ' + merge_data_high_low_python + ' -seq {params.prot_seq} -ldata {input.lowph_fpath} -ldf {params.lowph_d2o_frac} -ldp {params.lowph_d2o_pur} -lbk {params.low_ph_bkexch} -lbkc {input.lowph_corr_fpath} -hdata {input.highph_fpath} -hdf {params.highph_d2o_frac} -hdp {params.highph_d2o_pur} -hbk {params.high_ph_bkexch} -hbkc {input.highph_corr_fpath} -mbk {output.mergebkex_output} -mbkc {output.mergebkex_corr_output} -mdp {output.merge_dist_output} -mpp {output.merge_plot_output} -mfp {output.merge_factor_output}'
    #
    #
    # rule fit_hx_rates:
    #     input:
    #         hx_dist_fpath = merge_dpath + '/{low_high_name}/{low_high_name}_merge_hxms_dist.csv',
    #         backexch_array_file = merge_dpath + '/{low_high_name}/{low_high_name}_merge_backexchange.csv'
    #     params:
    #         prot_seq = lambda wildcards: seq_dict[wildcards.low_high_name],
    #         prot_name = '{low_high_name}',
    #         d2o_frac = config['high_ph_d2o_frac'],
    #         d2o_pur = config['high_ph_d2o_pur'],
    #         adjust_backexchange = config['adjust_backexchange'],
    #         num_chains = config['num_chains'],
    #         num_warmups = config['num_warmups'],
    #         num_samples = config['num_samples']
    #     output:
    #         pk_file = hxrate_dpath + '/{low_high_name}/{low_high_name}_hx_rate_fit.pickle',
    #         rate_csv_file = hxrate_dpath + '/{low_high_name}/{low_high_name}_hx_rate.csv',
    #         iso_dist_file = hxrate_dpath + '/{low_high_name}/{low_high_name}_hx_rate_theo_dist.csv',
    #         plot_file = hxrate_dpath + '/{low_high_name}/{low_high_name}_hx_rate.pdf'
    #     benchmark:
    #         benchmark_dpath + '/{low_high_name}_fit_hx_rate.benchmark.txt'
    #     shell:
    #         'python ' + hx_rate_fit_python_path + ' -p {params.prot_name} -s {params.prot_seq} -i {input.hx_dist_fpath} -df {params.d2o_frac} -dp {params.d2o_pur} -baf {input.backexch_array_file} -adb {params.adjust_backexchange} -nc {params.num_chains} -nw {params.num_warmups} -ns {params.num_samples} -o {output.pk_file} -or {output.rate_csv_file} -op {output.plot_file} -od {output.iso_dist_file}'
